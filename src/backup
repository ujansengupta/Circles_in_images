#include <iostream>
#include "ifs.h"
#include "flip.h"
#include "math.h"
#include <unistd.h>

using namespace std;

extern float **fifs2farr(IFSIMG);
#define PI 3.14159265


void convert(IFSIMG i1, IFSIMG i2, int rows, int cols)
{
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
			ifsfpp(i2,i,j,ifsfgp(i1,i,j));
}

void findEdge(IFSIMG input, IFSIMG edge, int rows, int cols, int thresh)
{

	float **ip = fifs2farr(input);

	for(int i=0; i<rows; i++)
	   	for(int j=0; j<cols; j++)
   			if(ip[i][j]>thresh)
   			{ 					 
   				if ((i-1)>0)
   					if (ip[i-1][j] == 0)
   					{
   					 	ifsfpp(edge, i, j, 255);
   					 	continue;
   					}
   				if ((i+1)<rows)
   					if (ip[i+1][j] == 0)
   					{
   						ifsfpp(edge, i, j, 255);
   					 	continue;
   					 	
   					}	
   				if ((j-1)>0)
   					if (ip[i][j-1] == 0)
   					{
   						ifsfpp(edge, i, j, 255);
   					 	continue;
   					}	
   				if ((j+1)<cols)
   					if (ip[i][j+1] == 0)
   					{
   						ifsfpp(edge, i, j, 255);
   					 	continue;
   					}
   			}
  	
   	//DOUBLE CHECK //
   	
   	for(int i=0; i<rows; i++)
   		for(int j=0; j<cols; j++)
   			if(ifsfgp(edge,i,j) == 255)
   			{ 					 
   				if ((i-1)>0)
   					if (ifsfgp(edge,i-1,j) == 0)
   					 	continue;
   				if ((i+1)<rows)
   					if (ifsfgp(edge,i+1,j) == 0)
   					 	continue;
   				if ((j-1)>0)
   					if (ifsfgp(edge,i,j-1) == 0)
   					 	continue;  					
   				if ((j+1)<cols)
   					if (ifsfgp(edge,i,j+1) == 0)
   					 	continue;
   			   				
   				ifsfpp(edge, i, j, ip[i][j]);
    		}
}


void findGrad (IFSIMG input, IFSIMG edge, IFSIMG mag, IFSIMG theta, int rows, int cols)
{
	IFSIMG tempx, tempy;
	float	**tempx_arr, **tempy_arr, **mag_arr, **theta_arr, **edge_arr, **filled;
	int first_pt, last_pt, row_count = 0;
	
	
	int len[] = {2,rows,cols};
	
	tempx = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
	tempy = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
	
	fldx(input, tempx);
	fldy(input, tempy);

	tempx_arr = fifs2farr(tempx);
	tempy_arr = fifs2farr(tempy);
	mag_arr = fifs2farr(mag);
	theta_arr = fifs2farr(theta);
	edge_arr = fifs2farr(edge);
	
	//Init filled//
	filled = new float *[rows];
    for (int i=0; i<rows; i++)
    	filled[i] = new float[cols];
	
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
			filled[i][j] = 0;
	//----------//
		
		
	for (int i=0; i<rows; i++)
	{
		row_count = 0;
		for (int j=0; j<cols; j++)
		{
			if (edge_arr[i][j] == 255)
			{
				if (row_count == 0)
				{
					first_pt = j;
					row_count++;
				}
				else
					last_pt = j;
			}
		}
		
		for (int j=0; j<cols; j++)
		{
			if (j == first_pt || j == last_pt)
				filled[i][j] = 255;
			else
				filled[i][j] = 0;
		}
	}
	
	int **newtheta = new int *[rows];
    for (int i=0; i<rows; i++)
    	newtheta[i] = new int[cols];
	
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
		{
			if (filled[i][j] == 255)
			{
				mag_arr[i][j] = sqrt(pow(tempx_arr[i][j],2)+pow(tempy_arr[i][j],2));
			
				if(tempy_arr[i][j] == 0 && tempx_arr[i][j] == 0)
					theta_arr[i][j] = 0;
				else
					theta_arr[i][j] = -1*(atan2(tempy_arr[i][j],tempx_arr[i][j]) * 180/PI);
				
				theta_arr[i][j] = theta_arr[i][j] + 180;
			
				if (theta_arr[i][j]>180)
					theta_arr[i][j] = theta_arr[i][j]-360;
			}
		}
	
	
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
		{
			newtheta[i][j] = -1;
			if (filled[i][j] == 255)
				newtheta[i][j] = theta_arr[i][j];
				
			ifsfpp(theta, i, j, newtheta[i][j]);
		}	
}


void findCenter (IFSIMG theta, int rows, int cols, int &centerx, int &centery, int **acc)
{
	int x_grad, y_grad, x, y;
	int highest = 0, num = 0, isum = 0, jsum = 0;
	float **theta_arr, temp;
	int len[] = {3,rows,cols,rows};
	int *hist = new int[rows*cols];
	IFSIMG iter = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
	
	theta_arr = fifs2farr(theta);
		
	
	for (int i=0; i<rows*cols; i++)
		hist[i] = 0;
	
	for (int i=0; i<rows; i++)
	{
		for (int j=0; j<cols; j++)
		{	
			if (theta_arr[i][j] >= 0) 
			{
				x = i;
				y = j;
				
				float cosine = cos (theta_arr[i][j] * PI/ 180.0);
				float sine = sin (theta_arr[i][j] * PI/ 180.0);
				
				if (cosine < 0)
				{
					temp = fabs (cosine);
					cosine = -1*(round(temp));
				}
				
				if (sine < 0)
				{
					temp = fabs (sine);
					cout<<temp<<" ";
					sine = -1*(round(temp));
				}
				
				x_grad = round(cosine); //Finding the increments in the direction of the gradient.
			 	y_grad = round(sine);
				
				while (x>0 && x<rows && y>0 && y<cols)
				{
					acc[x][y] += 1;		
					
					if(acc[x][y] > highest)
						highest = acc[x][y];
						
					x -= y_grad;
					y += x_grad;
					
					
					
			 	}
			 		
			 }	 
		}
		
		for (int p=0; p<rows; p++)
			for (int q=0; q<cols; q++)
				ifsfpp3d(iter, i, p, q, acc[p][q]);
	}

	ifspot(iter,(char *) "3d.ifs");
	
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
			hist[acc[i][j]] += 1;	
	
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
		{
			if (acc[i][j] > (highest - 2))
			{
				num++;
				isum += i;
				jsum += j;
			}
		}
			
	centerx = isum/num;
	centery = jsum/num;
	
	acc[centerx][centery] = 100;
}

void drawCircle (IFSIMG edge, IFSIMG circle, int centerx, int centery, int rows, int cols)
{
	float **edge_arr = fifs2farr(edge);
	float **filled;
	int x, y, radius, rad_temp, count = 0, first_pt, last_pt, row_count = 0;
	float h = centerx, k = centery;
	int *dist_arr = new int[rows*cols];
	
	//Init filled//
	filled = new float *[rows];
    for (int i=0; i<rows; i++)
    	filled[i] = new float[cols];
	
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
			filled[i][j] = 0;
	//----------//
	
	for (int i=0; i<rows; i++)
	{
		row_count = 0;
		for (int j=0; j<cols; j++)
		{
			if (edge_arr[i][j] == 255)
			{
				if (row_count == 0)
				{
					first_pt = j;
					row_count++;
				}
				else
					last_pt = j;
			}
		}
		
		for (int j=0; j<cols; j++)
		{
			if (j == first_pt || j == last_pt)
				filled[i][j] = 255;
			else
				filled[i][j] = 0;
		}
	}
   	
	//Finding distance of center from each edge point//
	for (int i=0; i<rows; i++)
		for (int j=0; j<cols; j++)
			if (filled[i][j] == 255)
			{
				rad_temp = sqrt(pow ((i-h),2) + pow ((j-k),2));
				dist_arr[rad_temp]++; 							//increase the count in the index which is = distance
				
				if (dist_arr[rad_temp]>count)
				{
					count = dist_arr[rad_temp];
					radius = rad_temp;
				}
					
			}
	
	for (int i=0; i<360; i+=2)
	{
		x = h + radius*cos(i*PI/ 180.0);
		y = k + radius*sin(i*PI/ 180.0);
		
		if (x>=0 && x<rows && y>=0 && y<cols)
			ifsfpp(circle, x, y, 255);
	}
	
	ifsfpp(circle, centerx, centery, 255);
}


int main(int c, char* argv[])
{
	int rows, cols, thresh = 30, centerx = 0, centery = 0;
    IFSIMG source, input, edge, circle, mag, theta, output;
  
    source = ifspin((char *) argv[1]);
    
   	cols = ifsdimen(source,0);
   	rows = ifsdimen(source,1);
   	
   	int len[] = {2,cols,rows};
	
   	mag = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
	theta = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
   	input = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
   	edge = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
   	output = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
   	circle = ifscreate((char *) "float", len, IFS_CR_ALL, 0);
	
   	convert(source, input, rows, cols);
   	convert(source, output, rows, cols);
	convert(source, edge, rows, cols);
	
	ifspot(source, (char *) "source.ifs");
	ifspot(input, (char *) "input.ifs");
   	
   	//DEFINE ACCUMULATOR ARRAY//
   	
    int **acc = new int *[rows];
    for (int i=0; i<rows; i++)
    	acc[i] = new int[cols];
    	
    for (int i=0; i<rows; i++)
   		for(int j=0; j<cols; j++)
   			acc[i][j] = 0;
    // ---------------------- //
   	
   	findEdge(input, edge, rows, cols, thresh);
   	findGrad(input, edge, mag, theta, rows, cols); 
	findCenter (theta, rows, cols, centerx, centery, acc);
	drawCircle (edge, circle, centerx, centery, rows, cols);

	//SUPERIMPOSE EDGE AND CENTER UPON ORIGINAL IMAGE//
	
	for (int i=0; i<rows; i++)
   		for(int j=0; j<cols; j++)
   		{
   			if (ifsfgp(circle, i, j) == 255)
   				ifsfpp(output, i, j, 255);
   		}
   			
   	ifsfpp(output, centerx, centery, 255);
   	
   	// --------------------------------------------- //

	ifsfpp(edge, centerx, centery, 255);
	ifspot(edge, (char *) "edge.ifs");
   	ifspot(output, (char *) "Output.ifs");
   	
   	ifsfree(source, IFS_FR_ALL);
   	ifsfree(input, IFS_FR_ALL);
   	ifsfree(output, IFS_FR_ALL);
   	ifsfree(edge, IFS_FR_ALL);
   	ifsfree(circle, IFS_FR_ALL);

}

